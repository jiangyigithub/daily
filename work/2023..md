# April.
## 4/13
## 4/17
- PI planning
## 4/18

## 4/23
1. debug ros python node `launch-prefix="xterm -e python -m pdb"`  
    for more: http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB
    python `PDB`: https://realpython.com/python-debugging-pdb/#getting-started-printing-a-variables-value
    ```bash
    # Set a breakpoint at line 10 of the current file
    break 10

    # Set a breakpoint at line 20 of the file "my_script.py"
    break my_script.py:20

    # Set a breakpoint at the start of the function "my_function"
    break my_script.my_function

    # Set a conditional breakpoint at line 30 of the current file
    break 30, some_variable == True
    ```

2. ros log `logwarn_throttle`  
    In ROS, logwarn_throttle is a method provided by the rospy Python library that allows you to log warning messages at a throttled rate.

    The logwarn_throttle method is similar to the rospy.logwarn method, but it limits the rate at which warning messages are printed to the console. This can be useful in situations where you have a large number of warnings that could overwhelm the console output, or when you want to avoid repeatedly printing the same warning message.

    Here's an example of how to use logwarn_throttle in a rospy node:
    ```python
    import rospy

    rospy.init_node('my_node')

    # Set the warning throttle rate to 10 seconds
    rospy.logwarn_throttle(10, "My warning message")

    # This warning message will only be printed every 10 seconds
    rospy.logwarn_throttle(10, "My warning message")

    # This warning message will be printed immediately
    rospy.logwarn("Another warning message")
    ```

    In this example, we first initialize a rospy node with the name "my_node".

    We then use the rospy.logwarn_throttle method to log a warning message with a throttle rate of 10 seconds. This means that the warning message will only be printed once every 10 seconds, even if the logwarn_throttle method is called multiple times.

    We then call logwarn_throttle again with the same warning message. Since the throttle rate is set to 10 seconds, this warning message will not be printed immediately, but will be queued and printed after the 10 second throttle period has elapsed.

    Finally, we use the rospy.logwarn method to log another warning message. This message will be printed immediately, regardless of the throttle rate set by logwarn_throttle.

    Note that logwarn_throttle can be used with any warning message, not just the string "My warning message" used in this example. You can also adjust the throttle rate to a different value by changing the first argument to logwarn_throttle.

3. `get_num_connections` for ROS python  
    In this code snippet, the get_num_connections() method is used to check if there are any subscribers to the topic associated with self.publisher.

    If get_num_connections() returns a value of 0, it means that there are no subscribers to the topic at the moment. In this case, the code returns from the function and does not publish the message.

    This can be useful in situations where you want to avoid publishing messages if there are no subscribers to the topic. By checking the number of connections before publishing the message, you can avoid unnecessary network traffic and processing.

    Here's an example of how you might use this code snippet in a rospy node:

    ```python

    import rospy
    from std_msgs.msg import String

    class MyNode:
        def __init__(self):
            self.publisher = rospy.Publisher('my_topic', String, queue_size=10)

        def publish_message(self, message):
            if self.publisher.get_num_connections() == 0:
                return
            self.publisher.publish(message)

    rospy.init_node('my_node')
    node = MyNode()

    message = String()
    message.data = 'Hello, world!'

    node.publish_message(message)
    ```

    In this example, we define a MyNode class with a publish_message() method that publishes a message to the my_topic topic if there are subscribers to the topic.

    We then initialize a rospy node, create a MyNode object, and call the publish_message() method with a String message.

    If there are no subscribers to the my_topic topic, the publish_message() method will return without publishing the message. If there are subscribers, the message will be published as usual.

## 4/24
1. RVIZ visulization

    RViz Plugin Development: This topic covers the development of custom RViz plugins for displaying custom visualizations in RViz. It includes topics such as creating custom `displays`, `panels`, and tools, as well as integrating custom ROS messages and services.

2. how to define coordinate frames in ROS

    ROS TF Transforms: This topic covers the use of the ROS TF (Transform) package for managing coordinate frames in ROS. It includes topics such as defining coordinate frames using URDF files or using a TF broadcaster node in robot software, as well as transforming coordinates between frames.
    - URDF (Unified Robot Description Format) file: URDF is an XML format used to describe a robot model. It includes information about the robot's links, joints, sensors, and other features. URDF files can be used to define coordinate frames for various parts of the robot.

    - TF broadcaster node: A TF broadcaster node is a ROS node that publishes transformations between coordinate frames. This node can be part of your robot software, and it can broadcast transformations based on sensor data or other inputs.[odometry demo](http://wiki.ros.org/navigation/Tutorials/RobotSetup/Odom)

3. vector usage  
    get element by the operation[], the system crash

## 4/26
1. Rviz:what the difference of panel and display in ros rviz  
    In ROS RViz, both "panels" and "displays" are used to visualize data, but they serve different purposes.

    A "panel" in RViz is a graphical user interface (GUI) component that provides additional functionality beyond what is provided by the main RViz display. Panels are typically used to modify the behavior or appearance of a display or to provide additional information about the data being visualized. For example, a panel might allow you to change the color of a marker, adjust the size of a point cloud, or enter a destination for a robot.

    A "display" in RViz, on the other hand, is the main component responsible for visualizing data. Displays are used to show data such as point clouds, laser scans, images, and other types of sensor data. Each display is associated with a particular topic in ROS, and updates its visualization whenever new data is received on that topic. Displays can be configured to show data in different ways, such as using different colors, sizes, or styles.

    In summary, panels are used to provide additional functionality or information to the user, while displays are used to actually visualize the data. Panels and displays can work together to create more powerful and customizable visualizations in RViz.

2. foxglove
    - To visualize a topic, the messages on that topic must conform to one of the known message schemas listed below.
    [message schemas list](https://foxglove.dev/docs/studio/panels/3d)
    - remapping topic , https://foxglove.dev/blog/using-message-converters-to-display-3d-markers-in-foxglove-studio
    - custom panel, 
    - User Scripts, https://foxglove.dev/docs/studio/panels/user-scripts

3. ROS TF

    [Robotics-Tutorial]https://articulatedrobotics.xyz/page2/
    http://wiki.ros.org/navigation/Tutorials/RobotSetup/TF

## 4/27
1. [ROS lecture](https://rsl.ethz.ch/education-students/lectures/ros.html)
2. how to get the value of shared pointer *share_pointer
3. common ROS message:
  pcl::PointCloud<pcl::PointXYZI> 
  sensor_msgs::PointCloud2>
4. ROS pub-sub mostest important concept
    - declare pub
    - define advertise
    - publish
    - constructor and callback
    - topic type and topic name

## 4/28
1. TF to static publish
rosrun tf2_ros static_transform_publisher 0.2 0 0.5 0 0 0 /baselink /laser 
https://zhuanlan.zhihu.com/p/358816230

2. foxglove message
ros_foxglove_msgs

## 5/8
1. TF

how to check TF status: http://wiki.ros.org/tf/Debugging%20tools
traditional https://www.ros.org/reps/rep-0105.html

https://inside-docupedia.bosch.com/confluence/display/MFAD/RRS+Coordinate+System+Study
https://inside-docupedia.bosch.com/confluence/display/HAD/Sensor

2. summary of material
[Robotics-Tutorial]https://articulatedrobotics.xyz/page2/
[ROS lecture](https://rsl.ethz.ch/education-students/lectures/ros.html)
[autonomous-racing-course]https://linklab-uva.github.io/autonomousracing/page3.html#content10-u

3. ssh in vscode
in bottom left of vscode

4. cmake build 
check the temp cmake generate file
build/geographic_transform/CMakeCache.txt

//The directory containing a CMake configuration file for Boost.
Boost_DIR:PATH=/usr/lib/x86_64-linux-gnu/cmake/Boost-1.71.0

//Path to a file.
Boost_INCLUDE_DIR:PATH=/usr/include

Boost_PYTHON_LIBRARY_RELEASE:STRING=/usr/lib/x86_64-linux-gnu/libboost_python38.so.1.71.0


## 5/10
1. visualization objects in foxglove
  - visualization_msgs/Marker.msg  --> for raw ROS message
  - foxglove_msgs/CubePrimitive.msg --> for foxglove message
    ```python
    # Position of the center of the cube and orientation of the cube
    geometry_msgs/Pose pose

    # Size of the cube along each axis
    geometry_msgs/Vector3 size

    # Color of the cube
    foxglove_msgs/Color color
    ```
    ```python
    geometry_msgs/Pose pose                 # Pose of the object
    geometry_msgs/Vector3 scale             # Scale of the object 1,1,1 means default (usually 1 meter square)
    std_msgs/ColorRGBA color             # Color [0.0-1.0]
    ```

2. CAN driver
    The CAN (Controller Area Network) protocol driver is a software component that enables communication between a computer or microcontroller and a CAN bus. The CAN protocol is commonly used in automotive and industrial applications for reliable and robust data communication.

    A CAN protocol driver typically provides an abstraction layer between the hardware and the application layer. It handles the low-level details of sending and receiving CAN messages, implementing the protocol's rules, and managing the hardware interfaces. The driver allows the application to interact with the CAN bus by providing a set of APIs (Application Programming Interfaces) or functions.

    Here are some key aspects of a CAN protocol driver:

        Initialization: The driver initializes the CAN controller and sets up the necessary hardware configurations, such as bitrate, acceptance filters, and error handling settings.

        Transmitting Messages: The driver provides functions to send CAN messages onto the bus. It takes care of packaging the data into the appropriate CAN message format and handling acknowledgments.

        Receiving Messages: The driver continuously listens to the CAN bus and receives incoming messages. It handles message filtering based on configured acceptance filters and delivers received messages to the application.

        Error Handling: The driver monitors and reports various error conditions that may occur on the CAN bus, such as bus-off, error frames, or transmission failures. It can also implement error recovery mechanisms.

        Synchronization and Timing: The driver ensures proper synchronization with the CAN bus and manages the timing requirements of the protocol, such as bit timing, synchronization segments, and arbitration rules.

        Configuration and Control: The driver allows the application to configure various parameters, such as bitrate, acceptance filters, and error handling settings, and provides control over the CAN controller, such as starting or stopping communication.

    CAN protocol drivers are available for different platforms and programming languages. They can be provided by the hardware manufacturer or developed by third-party software vendors. These drivers abstract the complexity of the underlying CAN hardware, making it easier for application developers to work with CAN networks and exchange data reliably.

    By utilizing a CAN protocol driver, developers can focus on implementing the higher-level functionality of their applications while leveraging the driver's capabilities for efficient and standardized communication over the CAN bus.

3. linux virtual CAN
    https://inside-docupedia.bosch.com/confluence/display/CRSHUT/Linux+CAN+Tools

    ```bash
    # Install CAN Tools
    $ sudo pip install cantools
    $ sudo apt install can-utils

    #Set up virtual CAN
    $ sudo modprobe vcan
    $ sudo ip link add can0 type vcan
    $ sudo ip link set can0 up

    #Show CAN Statistics
    $ ip -s -d link show can0

    #Send data to CAN
    $ cansend can0 200#DEADBEEFDEADBEEF
    $ while true; do cansend can0 200#DEADBEEFDEADBEEF; done

    #Dump CAN data
    ## Raw data:
    $ candump can0

    ## Filter by CAN Id:
    $ candump -c -ta can0,200:FFF

    #Play and Record CAN to Vector Format (*.BLF)
    ##Play:
    $ python -m can.player -i socketcan -c can0 test.blf

    ##Record:
    $ python -m can.logger -i socketcan -c can0 -f test.blf
    ```

4. linux file permission
chmod 777

## 5/11
1. URDF(fixed_joint)  
    In URDF, a fixed joint is used to represent a rigid connection between two links. The fixed joint does not allow any relative movement or rotation between the connected links. Here's an example of how to define a fixed joint in a URDF file:

    ```xml
    <?xml version="1.0" ?>
    <robot name="my_robot">

      <link name="link1">
        <!-- Define visual and collision properties for link1 -->
      </link>

      <link name="link2">
        <!-- Define visual and collision properties for link2 -->
      </link>

      <!-- Fixed joint -->
      <joint name="fixed_joint" type="fixed">
        <parent link="link1" />
        <child link="link2" />
        <origin xyz="1 0 0" rpy="0 0 0" />
      </joint>

    </robot>
    ```

    In this example, we have two links (`link1` and `link2`) connected by a fixed joint called `fixed_joint`. Here's a breakdown of the elements:

    - `<joint>`: This tag represents the joint element in the URDF.
      - `name`: Specifies the name of the joint (`fixed_joint` in this example).
      - `type`: Specifies the type of joint, which is `fixed` for a fixed joint.
    - `<parent>`: Specifies the parent link that the joint is connected to. In this case, the parent link is `link1`.
    - `<child>`: Specifies the child link that the joint is connected to. Here, the child link is `link2`.
    - `<origin>`: Defines the position and orientation of the joint relative to the parent link. The `xyz` attribute represents the translation, and the `rpy` attribute represents the roll, pitch, and yaw angles of the joint.

    By defining a fixed joint between `link1` and `link2`, you establish a rigid connection between them, allowing no relative motion or rotation.

    Remember to add visual and collision properties for each link to complete the URDF description.

    You can use this example as a starting point and extend it with additional links, joints, and other elements as needed for your specific robot model.

2. URDF with Xacro  
    Sure! Here's a tutorial on creating a URDF with Xacro and using it to define transformations using the TF (Transform) library in ROS:
    Step 1: Set up a ROS Package
    Create a new ROS package or use an existing one where you want to store your URDF files. Open a terminal and navigate to your ROS workspace.

    ```bash
    cd ~/catkin_ws/src
    catkin_create_pkg my_robot_description
    ```

    Step 2: Create the Xacro File
    Inside the `my_robot_description` package, create a `urdf` folder and a new Xacro file, e.g., `my_robot.xacro`. You can use any text editor to create the file.

    ```bash
    cd my_robot_description
    mkdir urdf
    touch urdf/my_robot.xacro
    ```

    Step 3: Edit the Xacro File
    Open `my_robot.xacro` in a text editor and define your robot's structure using Xacro macros and elements. Below is an example of a two-link robot with transformations:

    ```xml
    <?xml version="1.0" ?>
    <robot xmlns:xacro="http://ros.org/wiki/xacro" name="my_robot">

      <xacro:macro name="link" params="link_name">
        <link name="${link_name}">
          <!-- Define visual and collision properties for the link -->
        </link>
      </xacro:macro>

      <xacro:macro name="joint" params="joint_name parent_link child_link">
        <joint name="${joint_name}" type="fixed">
          <parent link="${parent_link}" />
          <child link="${child_link}" />
          <origin xyz="0 0 0" rpy="0 0 0" />
        </joint>
      </xacro:macro>

      <!-- Define the links and joints -->
      <xacro:link link_name="base_link" />
      <xacro:link link_name="link1" />
      <xacro:link link_name="link2" />

      <xacro:joint joint_name="joint1" parent_link="base_link" child_link="link1" />
      <xacro:joint joint_name="joint2" parent_link="link1" child_link="link2" />

    </robot>
    ```

    In this example, we use Xacro macros (`<xacro:macro>`) to define the link and joint elements. The macros allow us to reuse code and simplify the structure of the URDF. The `link` macro defines a link element, and the `joint` macro defines a fixed joint element.

    Step 4: Generate the URDF File
    To generate the URDF file from the Xacro file, you need to run the `xacro` command-line tool. In your package's CMakeLists.txt file, add the following lines to generate the URDF file during the build process:

    ```cmake
    # CMakeLists.txt

    # Find xacro package
    find_package(xacro REQUIRED)

    # Generate URDF file from Xacro
    xacro_add_xacro_file(urdf/my_robot.urdf.xacro urdf/my_robot.urdf)

    # Include URDF in the install target
    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/urdf/my_robot.urdf DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/urdf)
    ```

    Step 5: Build and Launch the URDF
    Build the package using `catkin_make` and launch the robot model in RViz to visualize it.

    ```bash
    cd ~/catkin_ws
    catkin_make
    source devel/setup.bash
    roslaunch my_robot_description display.launch model:=urdf/my_robot.urdf
    ```

    You should now see the robot model displayed in RViz

3. for our project
  - xacro
  - URDF
  - xacro_add_xacro_file # Generate URDF file from Xacro
  - robot_state_publisher # Publish TF transforms
```cmake
  set(expanded_file "${CMAKE_CURRENT_BINARY_DIR}/frames/${basename}.urdf")
  message(STATUS "    produce expanded file :" ,${expanded_file})

  xacro_add_xacro_file(${it} ${expanded_file} INORDER)
```

the output file:
build/vw01_golf_3654/frames/urdf.urdf

```xml ros launch file
  <!-- Publish TF transforms from vehicle origin to sensors -->
  <node pkg="robot_state_publisher" type="state_publisher" name="robot_state_publisher">
    <!-- Do not use static tf transforms. They will not be published when playing a bag file not from the beginning -->
    <param name="use_tf_static" value="false" />
  </node>
```

## 5/12
1. how to find .lib in linux
Verify the library path: Ensure that the library path is correct and accessible to CMake. Double-check the output of `ldconfig -p | grep eci` to confirm the exact library name and path.

2. can driver
https://www.ixxat.com/products/pc-interfaces-overview/details/can-ib600-pcie?ordercode=1.01.0233.12010

3. TF tutorial
https://foxglove.dev/blog/understanding-ros-transforms
https://rsl.ethz.ch/education-students/lectures/ros.html
{
TF Transformation System
rqt User Interface
Robot models (URDF)
Simulation descriptions (SDF)
}

4. robot business
https://www.roboticsbusinessreview.com/wp-content/uploads/2022/04/rbr50-2022-final.pdf

## 5/15
1. CAN /CANFD
CANFD --> DLC max=64
CAN --> DLC max=8

2. ROS version --> rosversion -d
ROS package location --> rospack find robot_state_publisher

3. publish TF
rosparam set /robot_description -t /home/jan5szh/workspaces/icv_ipc/build/icv_golf/frames/urdf.urdf
rosrun robot_state_publisher robot_state_publisher