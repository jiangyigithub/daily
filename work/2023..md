# April.
## 4/13
## 4/17
- PI planning
## 4/18

## 4/32
1. debug ros python node `launch-prefix="xterm -e python -m pdb"`  
    for more: http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB
    python `PDB`: https://realpython.com/python-debugging-pdb/#getting-started-printing-a-variables-value
    ```bash
    # Set a breakpoint at line 10 of the current file
    break 10

    # Set a breakpoint at line 20 of the file "my_script.py"
    break my_script.py:20

    # Set a breakpoint at the start of the function "my_function"
    break my_script.my_function

    # Set a conditional breakpoint at line 30 of the current file
    break 30, some_variable == True
    ```

2. ros log `logwarn_throttle`  
    In ROS, logwarn_throttle is a method provided by the rospy Python library that allows you to log warning messages at a throttled rate.

    The logwarn_throttle method is similar to the rospy.logwarn method, but it limits the rate at which warning messages are printed to the console. This can be useful in situations where you have a large number of warnings that could overwhelm the console output, or when you want to avoid repeatedly printing the same warning message.

    Here's an example of how to use logwarn_throttle in a rospy node:
    ```python
    import rospy

    rospy.init_node('my_node')

    # Set the warning throttle rate to 10 seconds
    rospy.logwarn_throttle(10, "My warning message")

    # This warning message will only be printed every 10 seconds
    rospy.logwarn_throttle(10, "My warning message")

    # This warning message will be printed immediately
    rospy.logwarn("Another warning message")
    ```

    In this example, we first initialize a rospy node with the name "my_node".

    We then use the rospy.logwarn_throttle method to log a warning message with a throttle rate of 10 seconds. This means that the warning message will only be printed once every 10 seconds, even if the logwarn_throttle method is called multiple times.

    We then call logwarn_throttle again with the same warning message. Since the throttle rate is set to 10 seconds, this warning message will not be printed immediately, but will be queued and printed after the 10 second throttle period has elapsed.

    Finally, we use the rospy.logwarn method to log another warning message. This message will be printed immediately, regardless of the throttle rate set by logwarn_throttle.

    Note that logwarn_throttle can be used with any warning message, not just the string "My warning message" used in this example. You can also adjust the throttle rate to a different value by changing the first argument to logwarn_throttle.

3. `get_num_connections` for ROS python  
    In this code snippet, the get_num_connections() method is used to check if there are any subscribers to the topic associated with self.publisher.

    If get_num_connections() returns a value of 0, it means that there are no subscribers to the topic at the moment. In this case, the code returns from the function and does not publish the message.

    This can be useful in situations where you want to avoid publishing messages if there are no subscribers to the topic. By checking the number of connections before publishing the message, you can avoid unnecessary network traffic and processing.

    Here's an example of how you might use this code snippet in a rospy node:

    ```python

    import rospy
    from std_msgs.msg import String

    class MyNode:
        def __init__(self):
            self.publisher = rospy.Publisher('my_topic', String, queue_size=10)

        def publish_message(self, message):
            if self.publisher.get_num_connections() == 0:
                return
            self.publisher.publish(message)

    rospy.init_node('my_node')
    node = MyNode()

    message = String()
    message.data = 'Hello, world!'

    node.publish_message(message)
    ```

    In this example, we define a MyNode class with a publish_message() method that publishes a message to the my_topic topic if there are subscribers to the topic.

    We then initialize a rospy node, create a MyNode object, and call the publish_message() method with a String message.

    If there are no subscribers to the my_topic topic, the publish_message() method will return without publishing the message. If there are subscribers, the message will be published as usual.

